= Three Ruby usages

: subtitle
   Inside Droonga
: author
   Kouhei Sutou
: institution
   ClearCode Inc.
: content-source
   RubyKaigi 2014
: date
   2014/09/20
: allotted-time
   28m
: theme
   .

= Conclusion

  * Describe three Ruby usages
    * Glue
    * Embed
    * High-level interface
  * Put them into your toolbox

= Why do I talk about it?

  * Ruby is not only for Rails
  * Ruby is not for all software
  * Ruby can be a good part of many software
  * Because ...

= Stop!

  * No time to describe about\n
    why you know these usages
    * (('note:Prepared it but it was too long!'))
    * (('note:Couldn't described these usages in time ðŸ˜ž'))
    * (('note:Interest? â†’ Speak to me after this talk'))
    * (('note:I show reasons, sample codes and benchmark results'))

= Goal

  * You know three Ruby usages
    * Glue
    * Embed
    * High-level interface
  * You can remember them later

= Not goal

Why you should know them\n
(('note:(Sorry)'))

= Case study

  # blockquote
  Implement distributed full-text search engine with Ruby

(('note:Abbreviation: DFTSE = Distributed Full-Text Search Engine'))

= DFTSE?

  # image
  # src = images/distributed-full-text-search-engine.svg
  # relative_width = 80

== slide property

: enable-title-on-image
   false

= Why do we use DFTSE?

Omit\n
(('note:(Sorry)'))

= DFTSE - Components

  * Full-text search engine\n
    (('note:(CPU, memory and I/O related operation)'))
  * Messaging system (('note:(Network operation)'))
  * Cluster management
  * Process management (('note:(Multiprocessing)'))

= Glue

  * ((*Glue*))
  * Embed
  * High-level interface

= Glue types

  * Use external library\n
    (('note:(a.k.a. Bindings or Extension library)'))
  * Use external command

= External library

  * Groonga
    * FTSE implemented by C
  * Bindings exist
    * Rroonga\n
      (('note:(I'm the author ðŸ˜ƒ)'))
    * Omit how to implement bindings

= FTSE

  * Must fast!
  * Hint:
    * Don't run CPU bound processing in Ruby
    * e.g.: Filter records

= TODO

= Groonga and Ruby

  * How to use Groonga?
    * As HTTP server
    * As library\n
      (The Ruby binding is Rroonga)
  * Which should we choose?

= FTSE - How to use?

HTTP server\n
vs.\n
Library

= Client vs. Binding

  * Ruby for client use
    * Network overhead
  * Ruby for binding use
    * Value conversion overhead

= Measure

  * Operations
    * Full-text search
    * Sort
    * Drilldown

= HTTP client

  # coderay ruby

  Net::HTTP.start("localhost", 10041) do |http|
    parameters = {
      "table"          => "Entries",
      "match_columns"  => "description",
      "query"          => "æ–‡å­—åˆ—",
      "sortby"         => "-_score",
      "limit"          => 10,
      "output_columns" => "label,version,description",
      "drilldown"      => "version",
      "cache"          => "no",
    }
    path = "/d/select?#{Rack::Utils.build_query(parameters)}"
    response = http.get(path)
    JSON.parse(response.body)
  end

= Binding

  # coderay ruby

  Groonga::Database.open(ARGV[0])
  entries = Groonga["Entries"]

  matched_records = entries.select do |record|
    record.description =~ "æ–‡å­—åˆ—"
  end
  sorted_records = matched_records.sort([["_score", :desc]], :limit => 10)
  sorted_records.each do |record|
    [record.score, record.label, record.version, record.description]
  end
  matched_records.group("version").each do |grouped_record|
    [grouped_record._key, grouped_record.n_sub_records]
  end

= Benchmark

(('tag:center'))Network overhead is larger

  # RT

  Type, Elapsed time

  HTTP client, 0.21s
  Binding,     0.07s

(('tag:center'))\n
(('note:Ruby reference manual in Japanese is used'))\n
(('note:72632 records, 319MB DB, Run only 1 request'))

= FTSE and Ruby

  * Use Groonga as library
    * Overhead is less than client
  * Note
    * How about concurrency?
    * How about scalability?

= Hint 1 - Concurrency

(('tag:center'))For CPU bound operation

  * Use multiprocessing
    * Ruby can't use all CPU cores by a process
    * Check whether library supports multiprocessing\n
      (('note:(Groonga supports multiprocessing)'))

= Hint 2 - Concurrency

(('tag:center'))For network bound operation

  * Use I/O multiplexing
    * You can use Cool.io or EventMachine for it\n
      (('note:(I like Cool.io because I like libev ðŸ˜ƒ)'))\n
      (('note:(But I don't like instance_eval API in Cool.io ðŸ˜ž)'))\n

= Hint 3 - Scalability

  * Keep "shared nothing" state\n
    (('note:(It makes "scale out"-able)'))
    * Combine sharding and replication for large data
    * Don't forget overhead for merging shards\n
      (('note:(It will be CPU bound that isn't good with Ruby)'))

= FTSE and Ruby again

  * Thought about using FTSE from Ruby
  * Let's think about using Ruby in FTSE

= FTSE characteristic

  * Must
    * Fast
  * Nice to have
    * Flexibility

= Flexibility

  * Query optimizer
    * Light operation than FTS
    * Depends on data\n
      (('note:(Choose effective index, use table scan and so on)'))
  * Plugin

= Query optimizer

  * Plan how to search

= Three Ruby usages

  * Glue
  * Embed
  * High-level interface

= Case study

Create a distributed full-text search engine based on existing
full-text search engine written by C

= How to use Ruby? (1)

Glue

= Glue

Combining existing features

= Existing features

  * Full-text search
  * (('del:Messaging system'))
    * Use Ruby for it?
  * (('del:Node management'))
    * Use Ruby for it?

= xxx

= Sample application

Droonga

  * Distributed full-text search engine
  * Requirements
    * Scalable
    * Fast
    * Easy to operate

= Components

  * Service API
  * Messaging system
  * Node management
  * Full-text search engine

= Service API

  * For using Droonga over network
  * Requirements
    * Scalable
    * Extensible
    * Fast

= Messaging system

  * For processing a task by nodes
  * Requirements
    * Scalable
    * Extensible
    * Fast

= Full-text search engine

  * For core feature
  * Requirements
    * Fast

= Architecture

  * Distributed system is complex
    * Internode communication
  * Similar software exists
    * Make Droonga workable
      even if it has only 60% features.

= Distributed system

  * Complex
    * Networking
    * Messaging system
    * Node management
  * Many CPU cores

= Using Ruby

  * Pros
    * Fast development
    * Flexible/Extensible system
  * Cons
    * Low performance rather than compile type languages such as C

= Trade-off

Think about:

  * Are pros needed?
  * Are cons acceptable?

= Pros

  * Fast development
    * Need: Similar software exists
  * Flexible/Extensible system
    * Nice to have

= Cons

  * Low performance per node
    * Acceptable if it is resolved by multiple CPU cores
      because Droonga assumes that Droonga cluster has many CPU cores
    * Not CPU things: I/O, Network, ...

= How slow?

Measure!\n
(('note:Because we are programmer'))\n
(('note:We should act based on fact rather than anticipation'))\n

= Where measure?

  * Components
    * Networking
    * Messaging system
    * Node management

= Networking

  * xxx

= Glue

  * c
