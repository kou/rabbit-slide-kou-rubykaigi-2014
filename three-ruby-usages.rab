= Three Ruby usages

: subtitle
   Inside Droonga
: author
   Kouhei Sutou
: institution
   ClearCode Inc.
: content-source
   RubyKaigi 2014
: date
   2014/09/20
: allotted-time
   28m
: theme
   .

= Conclusion

  * Describe three Ruby usages
    * High-level interface
    * Glue
    * Embed
  * Put them into your toolbox

= Goal

  * You know three Ruby usages
    * High-level interface
    * Glue
    * Embed
  * You can remember them later

= Case study

  # blockquote
  Implement distributed full-text search engine in Ruby

(('note:Abbreviation: DFTSE = Distributed Full-Text Search Engine'))

= DFTSE?

  # image
  # src = images/distributed-full-text-search-engine.svg
  # relative_width = 80

== slide property

: enable-title-on-image
   false

= Why do we use DFTSE?

I'm developing Droonga\n
(('note:(A DFTSE implementation in Ruby)'))\n
ðŸ˜ƒ

= Messaging system

(('tag:center'))DFTSE components

  * Full-text search engine
  * ((*Messaging system*))
  * Cluster management
  * Process management

= Messaging system

  # image
  # src = images/droonga-messaging-system.svg
  # relative_width = 80

== slide property

: enable-title-on-image
   false

= High-level interface

(('tag:center'))Three Ruby usages

  * ((*High-level interface*))
  * Glue
  * Embed

= Messaging system

  * Plan how to search
  * Distribute requests
  * Merge responses

= Characteristic

  * Plan how to search
    * May speed up/down over 100 times
  * Distribute requests
    * Network bound operation
  * Merge responses
    * CPU and network bound operation

= Messaging system

  * Algorithm is important
    * Rapid prototype and measure feedback loop is helpful
  * Ruby is good for\n
    rapid development

= The current Droonga\nMessaging system

  * Isn't good yet ðŸ˜ž
  * Need more feedback loops
  * Leaning algorithms
    * BSP, Dryad, CIEL, ...

= Glue

(('tag:center'))Three Ruby usages

  * High-level interface
  * ((*Glue*))
  * Embed

= What is gluing

  * Exporting a feature
  * Combining features

= Glue

  # image
  # src = images/glue.svg
  # relative_width = 80

== slide property

: enable-title-on-image
   false

= Why do we glue?

  * Reuse existing features

= How to glue

  * Use external library
    * (('wait'))Implement bindings
  * Use external command
    * (('wait'))Spawn command
  * Use external service
    * (('wait'))Implement client

= Glue in Droonga

  * ((*Rroonga*)): Groonga bindings
    * Groonga: FTSE C library (('note:(and server)'))
  * Cool.io: libev bindings
    * libev: Event loop C library\n
      (('note:(Based on I/O multiplexing and non-blocking I/O)'))
  * Event handler for Serf
    * Serf: Cluster management tool

= Rroonga in Droonga

  # image
  # src = images/droonga-rroonga.svg
  # relative_width = 80

== slide property

: enable-title-on-image
   false

= FTSE in Droonga

  * Must be fast!
  * CPU bound processing

= For fast Rroonga

  * ((*Do heavy processing in C*))
    * Nice to have Ruby-ish API
  * Less memory allocation
    * Cache internal buffer
  * Multiprocessing
    * Groonga supports multiprocessing

= Search

  # coderay ruby

  Groonga::Database.open(ARGV[0])
  entries = Groonga["Entries"]

  entries.select do |record|
    record.description =~ "Ruby"
  end

= Search - Pure Ruby (ref)

  # coderay ruby

  Groonga::Database.open(ARGV[0])
  entries = Groonga["Entries"]

  entries.find_all do |record|
    /Ruby/ =~ record.description
  end

= Search impl.

  # coderay ruby

  # (2) Evaluate expression in C
  entries.select do |record|
    # (1) Build expression in Ruby
    # This block is evaluated only once
    record.description =~ "Ruby"
  end

= Search impl. - Fig.

  # image
  # src = images/rroonga-search.svg
  # relative_width = 80

== slide property

: enable-title-on-image
   false

= Search - Benchmark

  * Ruby (('note:(It's already showed)'))
  * C

= Search - C

  # coderay c

  grn_obj *expr;
  grn_obj *variable;
  const gchar *filter = "description @ \"Ruby\"";
  grn_obj *result;

  GRN_EXPR_CREATE_FOR_QUERY(&ctx, table, expr, variable);
  grn_expr_parse(&ctx, expr,
                 filter, strlen(filter), NULL,
                 GRN_OP_MATCH, GRN_OP_AND,
                 GRN_EXPR_SYNTAX_SCRIPT);
  result = grn_table_select(&ctx, table, expr, NULL, GRN_OP_OR);
  grn_obj_unlink(&ctx, expr);
  grn_obj_unlink(&ctx, result);

= Search - Benchmark

(('tag:center'))Fast enough with Ruby

  # RT

  Impl., Elapsed time

  C,       0.6ms
  Ruby,    0.8ms

(('tag:center'))\n
(('note:(Full-text search with "Ruby" against 72632 records)'))

= More faster

  * Improve messaging system
    * May speed up over 100 times
  * ((*Improve FTSE*))
    * May speed up over 100 times

= How to improve FTSE

  * Use index effectively
    * Add new index search feature
    * Tune query optimizer

= TODO

= Embed

(('tag:center'))Three Ruby usages

  * High-level interface
  * Glue
  * ((*Embed*))

= TODO

= Groonga and Ruby

  * How to use Groonga?
    * As HTTP server
    * As library\n
      (The Ruby binding is Rroonga)
  * Which should we choose?

= FTSE - How to use?

HTTP server\n
vs.\n
Library

= Client vs. Binding

  * Ruby for client use
    * Network overhead
  * Ruby for binding use
    * Value conversion overhead

= Measure

  * Operations
    * Full-text search
    * Sort
    * Drilldown

= HTTP client

  # coderay ruby

  Net::HTTP.start("localhost", 10041) do |http|
    parameters = {
      "table"          => "Entries",
      "match_columns"  => "description",
      "query"          => "æ–‡å­—åˆ—",
      "sortby"         => "-_score",
      "limit"          => 10,
      "output_columns" => "label,version,description",
      "drilldown"      => "version",
      "cache"          => "no",
    }
    path = "/d/select?#{Rack::Utils.build_query(parameters)}"
    response = http.get(path)
    JSON.parse(response.body)
  end

= Binding

  # coderay ruby

  Groonga::Database.open(ARGV[0])
  entries = Groonga["Entries"]

  matched_records = entries.select do |record|
    record.description =~ "æ–‡å­—åˆ—"
  end
  sorted_records = matched_records.sort([["_score", :desc]], :limit => 10)
  sorted_records.each do |record|
    [record.score, record.label, record.version, record.description]
  end
  matched_records.group("version").each do |grouped_record|
    [grouped_record._key, grouped_record.n_sub_records]
  end

= Benchmark

(('tag:center'))Network overhead is larger

  # RT

  Type, Elapsed time

  HTTP client, 0.21s
  Binding,     0.07s

(('tag:center'))\n
(('note:Ruby reference manual in Japanese is used'))\n
(('note:72632 records, 319MB DB, Run only 1 request'))

= FTSE and Ruby

  * Use Groonga as library
    * Overhead is less than client
  * Note
    * How about concurrency?
    * How about scalability?

= Hint 1 - Concurrency

(('tag:center'))For CPU bound operation

  * Use multiprocessing
    * Ruby can't use all CPU cores by a process
    * Check whether library supports multiprocessing\n
      (('note:(Groonga supports multiprocessing)'))

= Hint 2 - Concurrency

(('tag:center'))For network bound operation

  * Use I/O multiplexing
    * You can use Cool.io or EventMachine for it\n
      (('note:(I like Cool.io because I like libev ðŸ˜ƒ)'))\n
      (('note:(But I don't like instance_eval API in Cool.io ðŸ˜ž)'))\n

= Hint 3 - Scalability

  * Keep "shared nothing" state\n
    (('note:(It makes "scale out"-able)'))
    * Combine sharding and replication for large data
    * Don't forget overhead for merging shards\n
      (('note:(It will be CPU bound that isn't good with Ruby)'))

= FTSE and Ruby again

  * Thought about using FTSE from Ruby
  * Let's think about using Ruby in FTSE

= FTSE characteristic

  * Must
    * Fast
  * Nice to have
    * Flexibility

= Flexibility

  * Query optimizer
    * Light operation than FTS
    * Depends on data\n
      (('note:(Choose effective index, use table scan and so on)'))
  * Plugin

= Query optimizer

  * Plan how to search

= Three Ruby usages

  * Glue
  * Embed
  * High-level interface

= Case study

Create a distributed full-text search engine based on existing
full-text search engine written by C

= How to use Ruby? (1)

Glue

= Glue

Combining existing features

= Existing features

  * Full-text search
  * (('del:Messaging system'))
    * Use Ruby for it?
  * (('del:Node management'))
    * Use Ruby for it?

= xxx

= Sample application

Droonga

  * Distributed full-text search engine
  * Requirements
    * Scalable
    * Fast
    * Easy to operate

= Components

  * Service API
  * Messaging system
  * Node management
  * Full-text search engine

= Service API

  * For using Droonga over network
  * Requirements
    * Scalable
    * Extensible
    * Fast

= Messaging system

  * For processing a task by nodes
  * Requirements
    * Scalable
    * Extensible
    * Fast

= Full-text search engine

  * For core feature
  * Requirements
    * Fast

= Architecture

  * Distributed system is complex
    * Internode communication
  * Similar software exists
    * Make Droonga workable
      even if it has only 60% features.

= Distributed system

  * Complex
    * Networking
    * Messaging system
    * Node management
  * Many CPU cores

= Using Ruby

  * Pros
    * Fast development
    * Flexible/Extensible system
  * Cons
    * Low performance rather than compile type languages such as C

= Trade-off

Think about:

  * Are pros needed?
  * Are cons acceptable?

= Pros

  * Fast development
    * Need: Similar software exists
  * Flexible/Extensible system
    * Nice to have

= Cons

  * Low performance per node
    * Acceptable if it is resolved by multiple CPU cores
      because Droonga assumes that Droonga cluster has many CPU cores
    * Not CPU things: I/O, Network, ...

= How slow?

Measure!\n
(('note:Because we are programmer'))\n
(('note:We should act based on fact rather than anticipation'))\n

= Where measure?

  * Components
    * Networking
    * Messaging system
    * Node management

= Networking

  * xxx

= Glue

  * c
