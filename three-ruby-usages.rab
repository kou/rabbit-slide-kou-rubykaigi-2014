= Three Ruby usages

: subtitle
   Inside Droonga
: author
   Kouhei Sutou
: institution
   ClearCode Inc.
: content-source
   RubyKaigi 2014
: date
   2014/09/20
: allotted-time
   28m
: theme
   .

= Summary

  * Expand Ruby usable area
  * Cooperate with other langs
  * Some patterns for it exist

= Goal

You acquire ability to...

  * use Ruby more areas
  * stop using Ruby every case

= Key idea: trade-off

  * What you can drop
  * What you can't drop

= Case study

  # blockquote
  Implement distributed full-text search engine

(('note:Abbreviation: DFTSE = Distributed Full-Text Search Engine'))

= DFTSE?

  # image
  # src = images/distributed-full-text-search-engine.svg
  # relative_width = 80

== slide property

: enable-title-on-image
   false

= How to implement DFTSE?

  * Where do we use Ruby?
  * How do we use Ruby?
  * (('wait'))Where ((*don't*)) we use Ruby?

= Ruby's Pros/Cons

  * Pros
    * Fun
    * Rapid development
  * Cons
    * Slower (('note:rather than compile style languages'))

= Key idea: trade-off

  * What you can drop
  * What you can't drop

= Think about slower

  * Acceptable?
    * Yes with reservations
  * Reservations
    * It's fast enough or\n
      ("can drop" case)
    * It's not ((*the bottle neck*))\n
      ("can't drop" case)

= Point 1

Don't use Ruby for speed matter case

= DFTSE components

  * FTSE (('note:(Full-Text Search Engine)'))
  * Messaging system
  * Node management

= FTSE - an impl.

  * Groonga
    * FTSE implemented by C\n
      (('note:(Full-Text Search Engine)'))
    * Library and HTTP server
  * Rroonga
    * The Ruby bindings of Groonga
    * Library

= FTSE - how to use?

Groonga server\n
vs.\n
Rroonga

= Client vs. Bindings

  * Ruby for client use
    * Network overhead
  * Ruby for bindings use
    * Value conversion overhead

= Measure

= Point 2 - overhead

Network\n
>\n
Bindings

= DFTSE components

  * FTSE (('note:(Full-Text Search Engine)'))
  * ((*Messaging system*))
  * Node management

= Messaging system

  * (({messages.each do |message|}))
    * Parse (({message}))
    * Compute how to process (({message}))
    * Dispatch (({message})) to workers
    * Collect results
  * (({end}))

= Messaging system - fig.

xxx

= Messaging system

  * Complex
    * Rapid development is helpful\n
      (('note:(Ruby is suitable)'))
  * Scalable (MUST)
    * Many CPUs are usable

= Scalable\nmessaging system

  * Less messages
    * Reduce network I/O
  * Smaller messages
    * Reduce network I/O
    * Reduce serialize overhead

= Less messages

  * Measure
    * Less messages
    * More messages

= Smaller messages

  * Measure
    * Small messages
    * Large messages

= Consider

  * Is Ruby usable for this case?
    * Rapid development is helpful against complex
    * Slow?

= Key idea: trade-off

  * What you can drop
  * What you can't drop

= Think about slower

  * Acceptable?
    * Yes with reservations
  * Reservations
    * It's fast enough or\n
      ("can drop" case)
    * It's not ((*the bottle neck*))\n
      ("can't drop" case)

= Node management

  * FTSE (('note:(Full-Text Search Engine)'))
  * Messaging system
  * ((*Node management*))

= Node management

  * Complex
  * Less CPU
  * Generic problem

= xxx

= FTSE again

  * ((*FTSE*)) (('note:(Full-Text Search Engine)'))
  * Messaging system
  * Node management

= FTSE flexibility

  * Query optimizer


= FTSE - CPU

(('note:(Full-Text Search Engine)'))

Speed related items

  * CPU - Ruby is slow
  * Memory
  * I/O

= CPU - Confirm

  * Is Ruby really slow?
  * Confirm!
    * We are programmer! :-)

= Tokenize - Bigram

  # coderay ruby

  tokens = []
  text.each_char.each_cons(2) do |characters|
    tokens << characters.join("")
  end

= Tokenize - Result

  * 27KB text (('note:(Wikipedia(ja) - Ruby)'))
  * Ruby: 0.016s
  * Go:   0.003s

(('note:https://github.com/kou/rabbit-slide-kou-rubykaigi-2014/tree/master/benchmark/tokenizer/'))

= Target Rubyists

  * Who use only Ruby
  * Who can't use Ruby yet

= Goal

  * Target Rubyists know options for...
    * when they use Ruby
    * where they use Ruby
    * how they use Ruby

= Key idea: trade-off


= Three Ruby usages

  * Glue
  * Embed
  * High-level interface

= Case study

Create a distributed full-text search engine based on existing
full-text search engine written by C

= How to use Ruby? (1)

Glue

= Glue

Combining existing features

= Existing features

  * Full-text search
  * (('del:Messaging system'))
    * Use Ruby for it?
  * (('del:Node management'))
    * Use Ruby for it?

= xxx

= Sample application

Droonga

  * Distributed full-text search engine
  * Requirements
    * Scalable
    * Fast
    * Easy to operate

= Components

  * Service API
  * Messaging system
  * Node management
  * Full-text search engine

= Service API

  * For using Droonga over network
  * Requirements
    * Scalable
    * Extensible
    * Fast

= Messaging system

  * For processing a task by nodes
  * Requirements
    * Scalable
    * Extensible
    * Fast

= Full-text search engine

  * For core feature
  * Requirements
    * Fast

= Architecture

  * Distributed system is complex
    * Internode communication
  * Similar software exists
    * Make Droonga workable
      even if it has only 60% features.

= Distributed system

  * Complex
    * Networking
    * Messaging system
    * Node management
  * Many CPU cores

= Using Ruby

  * Pros
    * Fast development
    * Flexible/Extensible system
  * Cons
    * Low performance rather than compile type languages such as C

= Trade-off

Think about:

  * Are pros needed?
  * Are cons acceptable?

= Pros

  * Fast development
    * Need: Similar software exists
  * Flexible/Extensible system
    * Nice to have

= Cons

  * Low performance per node
    * Acceptable if it is resolved by multiple CPU cores
      because Droonga assumes that Droonga cluster has many CPU cores
    * Not CPU things: I/O, Network, ...

= How slow?

Measure!\n
(('note:Because we are programmer'))\n
(('note:We should act based on fact rather than anticipation'))\n

= Where measure?

  * Components
    * Networking
    * Messaging system
    * Node management

= Networking

  * xxx

= Glue

  * c
