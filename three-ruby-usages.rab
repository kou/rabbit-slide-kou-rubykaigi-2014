= Three Ruby usages

: subtitle
   Inside Droonga
: author
   Kouhei Sutou
: institution
   ClearCode Inc.
: content-source
   RubyKaigi 2014
: date
   2014/09/20
: allotted-time
   28m
: theme
   .

= Conclusion by\n3 sentences

= Conclusion1

Ruby is not\n
only for\n
Rails

= Conclusion2

Ruby is not\n
for\n
all software

= Conclusion3

Ruby can be\n
a good part\n
of\n
many software

= Goal

You acquire ability to...

  * use Ruby more areas
  * stop using Ruby every case

with reasonable reasons

= Goal - In other words

Give you\n
a basis for\n
design decision

= Key idea: Trade-off

  * What you can drop
  * What you can't drop

= Case study

  # blockquote
  Implement distributed full-text search engine with Ruby

(('note:Abbreviation: DFTSE = Distributed Full-Text Search Engine'))

= DFTSE?

  # image
  # src = images/distributed-full-text-search-engine.svg
  # relative_width = 80

== slide property

: enable-title-on-image
   false

= Why do we use DFTSE?

(('note:DFTSE consists of'))\n
different characteristic components

= DFTSE - Components

  * Full-text search engine\n
    (('note:(CPU, memory and I/O related operation)'))
  * Messaging system (('note:(Network operation)'))
  * Cluster management
  * Process management (('note:(Multiprocessing)'))

= At this talk

No time\n
to talk about\n
all components\n
ðŸ˜§

= Think about only FTSE

  * ((*Full-text search engine*))\n
    (('note:(CPU, memory and I/O related operation)'))
  * Messaging system (('note:(Network operation)'))
  * Cluster management
  * Process management (('note:(Multiprocessing)'))

= Ruby for FTSE in DFTSE

  * Where do we use Ruby?
  * How do we use Ruby?
  * (('wait'))Where ((*don't*)) we use Ruby?

= Ruby's Pros/Cons

  * Pros
    * Fun ðŸ˜ƒ
    * Rapid development (('note:("trial & error"-able)'))
  * Cons
    * Slower (('note:rather than compile style languages'))

= Key idea: Trade-off

  * What you can drop
  * What you can't drop

= Think about "slower"

  * Acceptable?
    * Yes with reservations
  * Reservations
    * It's fast enough or\n
      ("can drop" case)
    * It's not ((*the bottle neck*))\n
      ("can't drop" case)

= FTSE characteristic

  * ((*CPU, memory*)) (('note:and I/O related'))\n
    operation
    * (('note:DB content should be on memory'))
  * One of core operations\n
    in DFTSE
    * FTSE is used many times

= To be faster

  * Less operations
  * Less memory allocations
  * Less I/O

(('tag:center'))They depend on algorithm rather than language speed

= Really?

Measure

= Less memory allocations

  * Implement (({cat}))
  * Parameter
    * Whether reuse read buffer

= cat - Not reuse

  # coderay ruby

  chunk_size = 4096
  loop do
    chunk = file.read(chunk_size)
    break if chunk.nil?
    print(chunk)
  end

= cat - Reuse

  # coderay ruby

  buffer_size = 4096
  buffer = ""
  loop do
    chunk = file.read(buffer_size, buffer)
    break if chunk.nil?
    print(chunk)
  end

= cat - Benchmark

(('tag:center'))Less memory allocations is ((*faster*))

  # RT

  Parameter, Elapsed time

  not reuse, 0.14s
  reuse,     0.07s

(('tag:center'))(('note:Input size: 200MiB'))

= Less I/O

  * Implement (({cat}))
  * Parameter
    * Read buffer size

= cat - C

  # coderay c

  char *buffer;
  buffer = malloc(buffer_size);
  while (1) {
    ssize_t read_size;
    read_size = read(fd, buffer, buffer_size);
    if (read_size == 0) {
      break;
    }
    write(STDOUT_FILENO, buffer, read_size);
  }
  free(buffer);

= cat - Benchmark

(('tag:center'))Ruby/8KiB is faster than C/1KiB

  # RT

  Size, C, Ruby

  1KiB, 0.08s, 0.17s
  4KiB, 0.04s, 0.07s
  8KiB, 0.03s, 0.05s
  16KiB, 0.03s, 0.04s

(('tag:center'))(('note:Input size: 200MiB'))

= Wrap the benchmark up

  * What it is try:
    * (('del:Less operations'))
    * Less memory allocations
    * Less I/O
    * Algorithm > Language speed
  * ((*Ruby can be faster*)) than C

= But!

  * Ruby isn't suitable for effective string processing
  * FTSE needs many string processings

= Bigram tokenizer

  * Split each 2 characters with duplication

= Example

  "Hello"

(('tag:center'))â†“ Bigram

  "He" "el" "ll" "lo"

= Bigram - each

  # coderay ruby

  tokens = []
  chars = text.each_char
  chars.each_cons(2) do |characters|
    # Memory allocation
    tokens << characters.join("")
  end

= Bigram - []

  # coderay ruby

  tokens = []
  (text.size - 1).times do |i|
    # Share substring
    # (Less memory allocations)
    tokens << text[i, 2]
  end

= Bigram - Benchmark

(('tag:center'))(({each})) is ((*faster*)) than (({[]}))

  # RT

  Language, each, []

  ja(27KiB), ((*0.01s*)), (('0.08s'))
  en(55KiB), ((*0.05s*)), (('0.56s'))

(('tag:center'))(('note:"Ruby" page at Wikipedia'))

= Bigram - Benchmark

(('tag:center'))(({each})) is ((*slower*)) than (({[]}))

  # RT

  ASCII only?, each, [], Go

  Yes, (('0.05s')), ((*0.01s*)), N/A
  No,  ((*0.05s*)), (('0.56s')), ((*0.01s*))

(('tag:center'))
(('note:English "Ruby" page at Wikipedia: 55KiB'))\n
(('note:"ASCII only" case replaces multibyte characters with "?"'))

= Wrap the benchmark up

  * What it is try:
    * Less operations\n
      (('note:(Accessing a UTF-8 char by index is inefficient)'))
    * Less memory allocations
  * Effective string processing is difficult in Ruby

= TODO

= Get back to the topic

  * Full-text search engine
    * ((*CPU, memory*)) (('note:and I/O related')) operation
    * One of core operations in DFTSE
    * FTSE is used many times
  * Can we use Ruby for it?

= FTSE by Ruby

  * Ruby is ((*not*)) suitable\n
    to implement FTSE
    * Effective string processing isn't good with Ruby
    * Core FTSE algorithm is stable
    * C > Ruby with the same algorithm

= FTSE and Ruby

  * Use existing FTSE
  * Fast FTSE exists: Groonga
    * FTSE implemented by C
    * HTTP server and library
  * We can use it from Ruby

= Groonga and Ruby

  * How to use Groonga?
    * As HTTP server
    * As library\n
      (The Ruby binding is Rroonga)
  * Which should we choose?

= FTSE - How to use?

HTTP server\n
vs.\n
Library

= Client vs. Binding

  * Ruby for client use
    * Network overhead
  * Ruby for binding use
    * Value conversion overhead

= Measure

  * Operations
    * Full-text search
    * Sort
    * Drilldown

= HTTP client

  # coderay ruby

  Net::HTTP.start("localhost", 10041) do |http|
    parameters = {
      "table"          => "Entries",
      "match_columns"  => "description",
      "query"          => "æ–‡å­—åˆ—",
      "sortby"         => "-_score",
      "limit"          => 10,
      "output_columns" => "label,version,description",
      "drilldown"      => "version",
      "cache"          => "no",
    }
    path = "/d/select?#{Rack::Utils.build_query(parameters)}"
    response = http.get(path)
    JSON.parse(response.body)
  end

= Binding

  # coderay ruby

  Groonga::Database.open(ARGV[0])
  entries = Groonga["Entries"]

  matched_records = entries.select do |record|
    record.description =~ "æ–‡å­—åˆ—"
  end
  sorted_records = matched_records.sort([["_score", :desc]], :limit => 10)
  sorted_records.each do |record|
    [record.score, record.label, record.version, record.description]
  end
  matched_records.group("version").each do |grouped_record|
    [grouped_record._key, grouped_record.n_sub_records]
  end

= Benchmark

(('tag:center'))Network overhead is larger

  # RT

  Type, Elapsed time

  HTTP client, 0.21s
  Binding,     0.07s

(('tag:center'))\n
(('note:Ruby reference manual in Japanese is used'))\n
(('note:72632 records, 319MB DB, Run only 1 request'))

= FTSE and Ruby

  * Use Groonga as library
    * Overhead is less than client
  * Note
    * How about concurrency?
    * How about scalability?

= Hint 1 - Concurrency

(('tag:center'))For CPU bound operation

  * Use multiprocessing
    * Ruby can't use all CPU cores by a process
    * Check whether library supports multiprocessing\n
      (('note:(Groonga supports multiprocessing)'))

= Hint 2 - Concurrency

(('tag:center'))For network bound operation

  * Use I/O multiplexing
    * You can use Cool.io or EventMachine for it\n
      (('note:(I like Cool.io because I like libev ðŸ˜ƒ)'))\n
      (('note:(But I don't like instance_eval API in Cool.io ðŸ˜ž)'))\n

= Hint 3 - Scalability

  * Keep "shared nothing" state\n
    (('note:(It makes "scale out"-able)'))
    * Combine sharding and replication for large data
    * Don't forget overhead for merging shards\n
      (('note:(It will be CPU bound that isn't good with Ruby)'))

= TODO

= Point 2 - overhead

Network\n
>\n
Bindings

= DFTSE components

  * FTSE (('note:(Full-Text Search Engine)'))
  * ((*Messaging system*))
  * Node management

= Messaging system

  * (({messages.each do |message|}))
    * Parse (({message}))
    * Compute how to process (({message}))
    * Dispatch (({message})) to workers
    * Collect results
  * (({end}))

= Messaging system - fig.

xxx

= Messaging system

  * Complex
    * Rapid development is helpful\n
      (('note:(Ruby is suitable)'))
  * Scalable (MUST)
    * Many CPUs are usable

= Scalable\nmessaging system

  * Less messages
    * Reduce network I/O
  * Smaller messages
    * Reduce network I/O
    * Reduce serialize overhead

= Less messages

  * Measure
    * Less messages
    * More messages

= Smaller messages

  * Measure
    * Small messages
    * Large messages

= Consider

  * Is Ruby usable for this case?
    * Rapid development is helpful against complex
    * Slow?

= Key idea: trade-off

  * What you can drop
  * What you can't drop

= Think about slower

  * Acceptable?
    * Yes with reservations
  * Reservations
    * It's fast enough or\n
      ("can drop" case)
    * It's not ((*the bottle neck*))\n
      ("can't drop" case)

= Node management

  * FTSE (('note:(Full-Text Search Engine)'))
  * Messaging system
  * ((*Node management*))

= Node management

  * Complex
  * Less CPU
  * Generic task

= xxx

= FTSE again

  * ((*FTSE*)) (('note:(Full-Text Search Engine)'))
  * Messaging system
  * Node management

= FTSE flexibility

  * Query optimizer


= FTSE - CPU

(('note:(Full-Text Search Engine)'))

Speed related items

  * CPU - Ruby is slow
  * Memory
  * I/O

= CPU - Confirm

  * Is Ruby really slow?
  * Confirm!
    * We are programmer! :-)

= Tokenize - Bigram

  # coderay ruby

  tokens = []
  text.each_char.each_cons(2) do |characters|
    tokens << characters.join("")
  end

= Tokenize - Result

  * 27KB text (('note:(Wikipedia(ja) - Ruby)'))
  * Ruby: 0.016s
  * Go:   0.003s

(('note:https://github.com/kou/rabbit-slide-kou-rubykaigi-2014/tree/master/benchmark/tokenizer/'))

= Target Rubyists

  * Who use only Ruby
  * Who can't use Ruby yet

= Goal

  * Target Rubyists know options for...
    * when they use Ruby
    * where they use Ruby
    * how they use Ruby

= Key idea: trade-off


= Three Ruby usages

  * Glue
  * Embed
  * High-level interface

= Case study

Create a distributed full-text search engine based on existing
full-text search engine written by C

= How to use Ruby? (1)

Glue

= Glue

Combining existing features

= Existing features

  * Full-text search
  * (('del:Messaging system'))
    * Use Ruby for it?
  * (('del:Node management'))
    * Use Ruby for it?

= xxx

= Sample application

Droonga

  * Distributed full-text search engine
  * Requirements
    * Scalable
    * Fast
    * Easy to operate

= Components

  * Service API
  * Messaging system
  * Node management
  * Full-text search engine

= Service API

  * For using Droonga over network
  * Requirements
    * Scalable
    * Extensible
    * Fast

= Messaging system

  * For processing a task by nodes
  * Requirements
    * Scalable
    * Extensible
    * Fast

= Full-text search engine

  * For core feature
  * Requirements
    * Fast

= Architecture

  * Distributed system is complex
    * Internode communication
  * Similar software exists
    * Make Droonga workable
      even if it has only 60% features.

= Distributed system

  * Complex
    * Networking
    * Messaging system
    * Node management
  * Many CPU cores

= Using Ruby

  * Pros
    * Fast development
    * Flexible/Extensible system
  * Cons
    * Low performance rather than compile type languages such as C

= Trade-off

Think about:

  * Are pros needed?
  * Are cons acceptable?

= Pros

  * Fast development
    * Need: Similar software exists
  * Flexible/Extensible system
    * Nice to have

= Cons

  * Low performance per node
    * Acceptable if it is resolved by multiple CPU cores
      because Droonga assumes that Droonga cluster has many CPU cores
    * Not CPU things: I/O, Network, ...

= How slow?

Measure!\n
(('note:Because we are programmer'))\n
(('note:We should act based on fact rather than anticipation'))\n

= Where measure?

  * Components
    * Networking
    * Messaging system
    * Node management

= Networking

  * xxx

= Glue

  * c
