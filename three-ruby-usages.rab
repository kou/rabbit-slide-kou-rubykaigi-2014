= Three Ruby usages

: subtitle
   Inside Droonga
: author
   Kouhei Sutou
: institution
   ClearCode Inc.
: content-source
   RubyKaigi 2014
: date
   2014/09/20
: allotted-time
   28m
: theme
   .

= Three Ruby usages

  * Glue
  * Embed
  * High-level interface

= Conclusion by\n2 sentences

= Conclusion1

Ruby is not\n
for\n
all software

= Conclusion2

Ruby can be\n
a good part\n
of\n
many software

= Goal

You acquire ability to...

  * use Ruby more areas
  * stop using Ruby every case

with ((*reasonable reasons*))

= Goal - In other words

Give you\n
a basis for\n
design decision

= Key idea: Trade-off

  * What you can drop
  * What you can't drop

= Most cases for Ruby

  * You can drop speed?
  * You can't drop speed?

(('tag:center'))
(('note:(I'm not speedster)'))\n
(('note:(Normally, I don't think about speed ðŸ˜›)'))

= Question1 - Use Ruby?

To implement "cat"

= cat by Ruby

  # coderay ruby

  IO.copy_stream(ARGF, $stdout)

= Question2 - Use Ruby?

To implement "grep"

= grep by Ruby(1)

  # coderay ruby

  pattern = Regexp.new(ARGV.shift)
  ARGF.each_line.grep(pattern) do |line|
    print(line)
  end

= grep by Ruby(2)

  # coderay ruby

  system("grep", *ARGV)

= Question3 - Use Ruby?

To implement echo server

= echo server by Ruby(1)

  # coderay ruby

  require "socket"
  TCPServer.open(2929) do |server|
    loop do
      Thread.new(server.accept) do |client|
        while (line = client.gets)
          client.write(line)
        end
        client.close
      end
    end
  end

= echo server by Ruby(2)

  # coderay ruby

  require "webrick"
  server = WEBrick::GenericServer.new(:Port => 2929)
  server.start do |client|
    while (line = client.gets)
      client.write(line)
    end
  end

= Question4 - Use Ruby?

To implement memcached

= Why?

  * Why did you use Ruby?
  * Why did not you use Ruby?

= Goal

You acquire ability to...

  * use Ruby more areas
  * stop using Ruby every case

with ((*reasonable reasons*))

= Three Ruby usages

  * Glue
  * Embed
  * High-level interface

= Case study

  # blockquote
  Implement distributed full-text search engine with Ruby

(('note:Abbreviation: DFTSE = Distributed Full-Text Search Engine'))

= DFTSE?

  # image
  # src = images/distributed-full-text-search-engine.svg
  # relative_width = 80

== slide property

: enable-title-on-image
   false

= Why do we use DFTSE?

(('note:DFTSE consists of'))\n
different characteristic components

= DFTSE - Components

  * Full-text search engine\n
    (('note:(CPU, memory and I/O related operation)'))
  * Messaging system (('note:(Network operation)'))
  * Cluster management
  * Process management (('note:(Multiprocessing)'))

= At this talk

No time\n
to talk about\n
all components\n
ðŸ˜§

= Think about only FTSE

  * ((*Full-text search engine*))\n
    (('note:(CPU, memory and I/O related operation)'))
  * Messaging system (('note:(Network operation)'))
  * Cluster management
  * Process management (('note:(Multiprocessing)'))

= Ruby for FTSE in DFTSE

  * Where do we use Ruby?
  * How do we use Ruby?
  * (('wait'))Where ((*don't*)) we use Ruby?

= Ruby's Pros/Cons

  * Pros
    * Fun ðŸ˜ƒ
    * Rapid development (('note:("trial & error"-able)'))
  * Cons
    * Slower (('note:rather than compile style languages'))

= Key idea: Trade-off

  * What you can drop
  * What you can't drop

= Think about "slower"

  * Acceptable?
    * Yes with reservations
  * Reservations
    * It's fast enough or\n
      ("can drop" case)
    * It's not ((*the bottle neck*))\n
      ("can't drop" case)

= Bottle neck?

  * cat
    * will not be bottle neck (('note:(maybe I/O)'))
  * grep
    * may be bottle neck for\n
      over 100MB data

= Bottle neck?

  * echo-server
    * will not be bottle neck\n
      because of less connections
  * memcached
    * will be bottle neck\n
      because of many connections

= FTSE characteristic

  * ((*CPU, memory*)) (('note:and I/O related'))\n
    operation
    * (('note:DB content should be on memory'))
  * One of core operations\n
    in DFTSE
    * FTSE is used many times

= To be faster

  * Less operations
  * Less memory allocations
  * Less I/O

(('tag:center'))They depend on algorithm rather than language speed

= Really?

Measure

= Less memory allocations

  * Implement (({cat}))
  * Parameter
    * Whether reuse read buffer

= cat - Not reuse

  # coderay ruby

  chunk_size = 4096
  loop do
    chunk = file.read(chunk_size)
    break if chunk.nil?
    print(chunk)
  end

= cat - Reuse

  # coderay ruby

  buffer_size = 4096
  buffer = ""
  loop do
    chunk = file.read(buffer_size, buffer)
    break if chunk.nil?
    print(chunk)
  end

= cat - Benchmark

(('tag:center'))Less memory allocations is ((*faster*))

  # RT

  Parameter, Elapsed time

  not reuse, 0.14s
  reuse,     0.07s

(('tag:center'))(('note:Input size: 200MiB'))

= Less I/O

  * Implement (({cat}))
  * Parameter
    * Read buffer size

= cat - C

  # coderay c

  char *buffer;
  buffer = malloc(buffer_size);
  while (1) {
    ssize_t read_size;
    read_size = read(fd, buffer, buffer_size);
    if (read_size == 0) {
      break;
    }
    write(STDOUT_FILENO, buffer, read_size);
  }
  free(buffer);

= cat - Benchmark

(('tag:center'))Ruby/8KiB is faster than C/1KiB

  # RT

  Size, C, Ruby

  1KiB, 0.08s, 0.17s
  4KiB, 0.04s, 0.07s
  8KiB, 0.03s, 0.05s
  16KiB, 0.03s, 0.04s

(('tag:center'))(('note:Input size: 200MiB'))

= Wrap the benchmark up

  * What it is try:
    * Less memory allocations
    * Less I/O
    * Algorithm > Language speed
  * ((*Ruby can be faster*)) than C

= But!

  * Ruby isn't suitable for effective string processing
  * FTSE needs many string processings

= Bigram tokenizer

  * Split each 2 characters with duplication

= Example

  "Hello"

(('tag:center'))â†“ Bigram

  "He" "el" "ll" "lo"

= Bigram - each

  # coderay ruby

  tokens = []
  chars = text.each_char
  chars.each_cons(2) do |characters|
    # Memory allocation
    tokens << characters.join("")
  end

= Bigram - []

  # coderay ruby

  tokens = []
  (text.size - 1).times do |i|
    # Share substring
    # (Less memory allocations)
    tokens << text[i, 2]
  end

= Bigram - Benchmark

(('tag:center'))(({each})) is ((*faster*)) than (({[]}))

  # RT

  Language, each, []

  ja(27KiB), ((*0.01s*)), (('0.08s'))
  en(55KiB), ((*0.05s*)), (('0.56s'))

(('tag:center'))(('note:"Ruby" page at Wikipedia'))

= Bigram - Benchmark

(('tag:center'))(({each})) is ((*slower*)) than (({[]}))

  # RT

  ASCII only?, each, []

  Yes, (('0.051s')), ((*0.014s*))
  No,  ((*0.054s*)), (('0.536s'))

(('tag:center'))
(('note:English "Ruby" page at Wikipedia: 55KiB'))\n
(('note:"ASCII only" case replaces multibyte characters with "?"'))

= Bigram - Benchmark (ref)

  # RT

  Impl., Elapsed time

  Ruby(each), 0.051s
  Ruby([]),   0.014s
  Go,         0.010s
  C,          0.003s

(('tag:center'))
(('note:English "Ruby" page at Wikipedia: 55KiB'))\n
(('note:ASCII only text'))

= Wrap the benchmark up

  * What it is try:
    * Less operations\n
      (('note:(Accessing a UTF-8 char by index is inefficient)'))
    * Less memory allocations
  * Effective string processing is difficult in Ruby

= Get back to the topic

  * Full-text search engine
    * ((*CPU, memory*)) (('note:and I/O related')) operation
    * One of core operations in DFTSE
    * FTSE is used many times
  * Can we use Ruby for it?

= FTSE by Ruby

  * Ruby is ((*not*)) suitable\n
    to implement FTSE
    * Effective string processing isn't good with Ruby
    * Core FTSE algorithm is stable
    * C > Ruby with the same algorithm

= FTSE and Ruby

  * Use existing FTSE
  * Fast FTSE exists: Groonga
    * FTSE implemented by C
    * HTTP server and library
  * We can use it from Ruby

= Groonga and Ruby

  * How to use Groonga?
    * As HTTP server
    * As library\n
      (The Ruby binding is Rroonga)
  * Which should we choose?

= FTSE - How to use?

HTTP server\n
vs.\n
Library

= Client vs. Binding

  * Ruby for client use
    * Network overhead
  * Ruby for binding use
    * Value conversion overhead

= Measure

  * Operations
    * Full-text search
    * Sort
    * Drilldown

= HTTP client

  # coderay ruby

  Net::HTTP.start("localhost", 10041) do |http|
    parameters = {
      "table"          => "Entries",
      "match_columns"  => "description",
      "query"          => "æ–‡å­—åˆ—",
      "sortby"         => "-_score",
      "limit"          => 10,
      "output_columns" => "label,version,description",
      "drilldown"      => "version",
      "cache"          => "no",
    }
    path = "/d/select?#{Rack::Utils.build_query(parameters)}"
    response = http.get(path)
    JSON.parse(response.body)
  end

= Binding

  # coderay ruby

  Groonga::Database.open(ARGV[0])
  entries = Groonga["Entries"]

  matched_records = entries.select do |record|
    record.description =~ "æ–‡å­—åˆ—"
  end
  sorted_records = matched_records.sort([["_score", :desc]], :limit => 10)
  sorted_records.each do |record|
    [record.score, record.label, record.version, record.description]
  end
  matched_records.group("version").each do |grouped_record|
    [grouped_record._key, grouped_record.n_sub_records]
  end

= Benchmark

(('tag:center'))Network overhead is larger

  # RT

  Type, Elapsed time

  HTTP client, 0.21s
  Binding,     0.07s

(('tag:center'))\n
(('note:Ruby reference manual in Japanese is used'))\n
(('note:72632 records, 319MB DB, Run only 1 request'))

= FTSE and Ruby

  * Use Groonga as library
    * Overhead is less than client
  * Note
    * How about concurrency?
    * How about scalability?

= Hint 1 - Concurrency

(('tag:center'))For CPU bound operation

  * Use multiprocessing
    * Ruby can't use all CPU cores by a process
    * Check whether library supports multiprocessing\n
      (('note:(Groonga supports multiprocessing)'))

= Hint 2 - Concurrency

(('tag:center'))For network bound operation

  * Use I/O multiplexing
    * You can use Cool.io or EventMachine for it\n
      (('note:(I like Cool.io because I like libev ðŸ˜ƒ)'))\n
      (('note:(But I don't like instance_eval API in Cool.io ðŸ˜ž)'))\n

= Hint 3 - Scalability

  * Keep "shared nothing" state\n
    (('note:(It makes "scale out"-able)'))
    * Combine sharding and replication for large data
    * Don't forget overhead for merging shards\n
      (('note:(It will be CPU bound that isn't good with Ruby)'))

= FTSE and Ruby again

  * Thought about using FTSE from Ruby
  * Let's think about using Ruby in FTSE

= FTSE characteristic

  * Must
    * Fast
  * Nice to have
    * Flexibility

= Flexibility

  * Query optimizer
    * Light operation than FTS
    * Depends on data\n
      (('note:(Choose effective index, use table scan and so on)'))
  * Plugin

= Query optimizer

  * Plan how to search

= Three Ruby usages

  * Glue
  * Embed
  * High-level interface

= Case study

Create a distributed full-text search engine based on existing
full-text search engine written by C

= How to use Ruby? (1)

Glue

= Glue

Combining existing features

= Existing features

  * Full-text search
  * (('del:Messaging system'))
    * Use Ruby for it?
  * (('del:Node management'))
    * Use Ruby for it?

= xxx

= Sample application

Droonga

  * Distributed full-text search engine
  * Requirements
    * Scalable
    * Fast
    * Easy to operate

= Components

  * Service API
  * Messaging system
  * Node management
  * Full-text search engine

= Service API

  * For using Droonga over network
  * Requirements
    * Scalable
    * Extensible
    * Fast

= Messaging system

  * For processing a task by nodes
  * Requirements
    * Scalable
    * Extensible
    * Fast

= Full-text search engine

  * For core feature
  * Requirements
    * Fast

= Architecture

  * Distributed system is complex
    * Internode communication
  * Similar software exists
    * Make Droonga workable
      even if it has only 60% features.

= Distributed system

  * Complex
    * Networking
    * Messaging system
    * Node management
  * Many CPU cores

= Using Ruby

  * Pros
    * Fast development
    * Flexible/Extensible system
  * Cons
    * Low performance rather than compile type languages such as C

= Trade-off

Think about:

  * Are pros needed?
  * Are cons acceptable?

= Pros

  * Fast development
    * Need: Similar software exists
  * Flexible/Extensible system
    * Nice to have

= Cons

  * Low performance per node
    * Acceptable if it is resolved by multiple CPU cores
      because Droonga assumes that Droonga cluster has many CPU cores
    * Not CPU things: I/O, Network, ...

= How slow?

Measure!\n
(('note:Because we are programmer'))\n
(('note:We should act based on fact rather than anticipation'))\n

= Where measure?

  * Components
    * Networking
    * Messaging system
    * Node management

= Networking

  * xxx

= Glue

  * c
